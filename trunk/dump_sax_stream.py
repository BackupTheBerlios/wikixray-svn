import sys,os,codecs,string, datetime, random
from xml.sax import saxutils,make_parser
from xml.sax.handler import feature_namespaces, ContentHandler

class wikiHandler(ContentHandler):
    """Parse an XML file generated by Wikipedia Export page into SQL data
    suitable to be imported by MySQL"""
    def __init__(self):
        self.nspace_dict={}
        self.codens=''
        self.page_dict={}
        self.rev_dict = {}
        self.stack=[]
        self.current_text = ''
        self.current_elem=None
        self.revfile=None
        self.pagefile=None
        self.page_num = 1
        self.rev_num=1
        self.last_page_len=0
        self.rev_count=0
        self.prior_rev_id='NULL'
        self.isRedirect='0'
        self.isStub='0'
        self.isMinor='0'
        self.fileErrPath="./errors.log"
        
        self.start=datetime.datetime.now()
        self.timeCheck=None
        self.timeDelta=None
        
    def startElement(self, name, attrs):
##    Here we define which tags we want to catch
##        In this case, we only want to recall the name of the tags in a stack
##        so we can later look up the parent node of a new tag
##        (for instance, to discriminate among page id, rev id and contributor id
##        all of them with the name=="id")
        if name=='page' or name=='revision' or name=='contributor':
            self.stack.append(name)
        elif name=='namespace':
            self.codens=attrs.get('key')
        elif name=='minor':
            self.isMinor='1'
        self.current_text=''
        self.current_elem=name
        return
        
    def endElement(self, name):
##    Defining tasks to manage contents from the last readed tag
##        Catching the namespace of this page
        if name=='namespace':
            self.nspace_dict[self.current_text]=self.codens
            
        elif name=='id':
            if self.stack[-1]=='contributor':
                ##Detecting contributor's attributes inside a revision
                self.rev_dict['rev_user']=self.current_text
            elif self.stack[-1]=='revision':
                self.rev_dict[name]=self.current_text
            elif self.stack[-1]=='page':
                self.page_dict[name]=self.current_text
            else:
                self.f=open(self.fileErrPath,'w')
                if len(self.stack)>0:
                    self.f.write("Unsupported parent tag for '"+name+"': "+self.stack[-1])
                self.f.close()
                
        elif name=='ip':
            self.rev_dict['rev_user']='0'
            self.rev_dict['username']=self.current_text
            
        elif name=='timestamp':
            ##Adequate formatting of timestamps
            self.rev_dict['timestamp']=self.current_text.replace('Z','').replace('T',' ')
                
        elif name=='contributor':
            ##Pop contributor tag from the stack
            self.stack.pop()
            
        elif name=='revision':
            self.rev_count+=1
            ##Store whether this is a redirect or stub page or not
            if len(self.rev_dict['text'])>0:
                if string.upper(self.rev_dict['text'][0:9])=='#REDIRECT':
                    self.isRedirect='1'
                else:
                    self.isRedirect='0'
            ## Takes from the first argument the threshold for stub's length
            if str(8*len(self.rev_dict['text']))<=sys.argv[1]:
                self.isStub='1'
            else:
                self.isStub='0'
                
            ##Write revision contents to SQL file
            ##Values order: (rev_id, rev_page, rev_user, rev_user_text, rev_timestamp,
            ##rev_len, rev_letters, rev_words, rev_parent_id, rev_is_redirect, rev_is_stub, rev_is_minor, rev_comment)
            ##self.revfile = codecs.open(sys.argv[1],'a','utf_8')
            self.outEncoded=codecs.EncodedFile(sys.stdout,'utf_8','utf_8')
            
            self.outEncoded.write("INSERT INTO revision VALUES("+\
            self.rev_dict['id']+","+self.page_dict['id']+","+\
            self.rev_dict['rev_user']+",'"+self.rev_dict['username']+"','"+self.rev_dict['timestamp']+\
            "',"+str(8*len(self.rev_dict['text']))+\
            ","+str(len(self.rev_dict['text']))+\
            ","+str(len(self.rev_dict['text'].split())) +\
            ","+self.prior_rev_id+","+self.isRedirect+","+self.isStub+","+self.isMinor)
            
            if self.rev_dict.has_key('comment'):
                self.outEncoded.write(","+self.rev_dict['comment'])
            else:
                self.outEncoded.write(",''")
            self.outEncoded.write(");\n" )
            ##self.revfile.close()
            
            ##Store this rev_id to recall it when processing the following revision, if it exists
            self.prior_rev_id=self.rev_dict['id']
            ##Store this rev_len to recall it for the current page_len, in case this is the last revision for that page
            self.last_page_len=8*len(self.rev_dict['text'])
            
            self.rev_dict.clear()
            self.stack.pop()
            self.isMinor='0'
            if self.rev_num % 100 == 0:
                self.timeCheck=datetime.datetime.now()
                self.timeDelta=self.timeCheck-self.start
                if self.timeDelta.seconds==0:
                    print >> sys.stderr, "page %d (%f pags. per sec.), revision %d (%f revs. per sec.)" % (self.page_num,\
                    1e6*float(self.page_num)/self.timeDelta.microseconds, self.rev_num, 1e6*float(self.rev_num)/self.timeDelta.microseconds)
                else:
                    print >> sys.stderr, "page %d (%f pags. per sec.), revision %d (%f revs. per sec.)" % (self.page_num,\
                    float(self.page_num)/self.timeDelta.seconds, self.rev_num, float(self.rev_num)/self.timeDelta.seconds)
            self.rev_num+=1
            
        elif name=='page':
            ##Recovering namespace for this page
            if self.nspace_dict.has_key(self.page_dict['title'].split(':')[0]):
                self.page_dict['namespace']=self.nspace_dict[self.page_dict['title'].split(':')[0]]
            else:
                self.page_dict['namespace']='0'
            
            ##Values order for page (page_id, page_namespace, page_title,  page_latest, page_len, page_is_redirect, page_is_stub, page_is_new, page_restrictions)
            
            ##self.pagefile = codecs.open(sys.argv[2],'a','utf_8')
            self.outEncoded.write("INSERT INTO page VALUES("+\
            self.page_dict['id']+","+\
            self.page_dict['namespace']+",'"+\
            self.page_dict['title']+\
            "',"+self.prior_rev_id+","+str(self.last_page_len)+\
            ","+self.isRedirect+","+self.isStub+","+str(random.random()))
            if self.rev_count>1:
                self.outEncoded.write(",1")
            else:
                self.outEncoded.write(",0")
            if self.page_dict.has_key('restrictions'):
                self.outEncoded.write(",'"+self.page_dict['restrictions']+"'")
            else:
                self.outEncoded.write(",''")
            self.outEncoded.write(");\n" )
            ##self.pagefile.close()
            
            ##Clear temp variables for the next page
            self.page_dict.clear()
            self.prior_rev_id='NULL'
            self.last_page_len=0
            self.rev_count=0
            self.isRedirect='0'
            self.isStub='0'
            self.stack.pop()
            self.page_num += 1
                
        else:
            ##General tag processing
            if len(self.stack)>0 and (self.stack[-1]=='revision' or self.stack[-1]=='contributor'):
                self.rev_dict[self.current_elem]=self.current_text
            elif len(self.stack)>0 and self.stack[-1]=='page':
                self.page_dict[self.current_elem]=self.current_text
                
        self.current_elem=None
        return
             
    def characters(self, ch):
        if self.current_elem != None:
            self.current_text = self.current_text + ch
            
    def endDocument(self):
        self.timeCheck=datetime.datetime.now()
        self.timeDelta=self.timeCheck-self.start
        print >> sys.stderr, "\n"
        print >> sys.stderr, "File successfully parsed..."
        print >> sys.stderr, "page %d (%f pags./sec.), revision %d (%f revs./sec.)" % (self.page_num,\
        float(self.page_num)/self.timeDelta.seconds, self.rev_num, float(self.rev_num)/self.timeDelta.seconds)
if __name__ == '__main__':
    # Create a parser
    parser = make_parser()

    # Tell the parser we are not interested in XML namespaces
    parser.setFeature(feature_namespaces, 0)

    # Create the handler
    wh = wikiHandler()

    # Tell the parser to use our handler
    parser.setContentHandler(wh)

    # Parse the input
    parser.parse(codecs.EncodedFile(sys.stdin,'utf_8','utf_8'))
